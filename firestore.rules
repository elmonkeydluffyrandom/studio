/**
 * This ruleset enforces a strict user-ownership model for a digital bible study journal application.
 *
 * Core Philosophy:
 * The security model ensures that all user-generated content, including journal entries and tags,
 * is completely private. A user can only access, modify, or delete their own data. There is no
 * public or shared data.
 *
 * Data Structure:
 * All data is hierarchically organized under the `/users/{userId}` path. This structure naturally
 * isolates each user's data, making it simple and performant to secure the entire data tree
 * for a specific user with path-based rules.
 *   - /users/{userId}/journalEntries/{journalEntryId}
 *   - /users/{userId}/tags/{tagId}
 *
 * Key Security Decisions:
 * - Strict Ownership: All access is gated by matching the authenticated user's ID (`request.auth.uid`)
 *   with the `{userId}` wildcard in the document path.
 * - No User Listing: To protect user privacy, it is forbidden to list documents in the top-level
 *   `/users` collection.
 * - Prototyping Flexibility: In this prototyping phase, rules enforce *who* can access data but do
 *   not strictly validate the *shape* of that data. This allows for rapid iteration on the frontend
 *   without needing to update security rules for every schema change.
 * - Authorization over Validation: For optimal performance and simplicity, authorization decisions
 *   are made using the document path. There is no need for slow `get()` calls to other documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to improve readability and maintainability.

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of the document,
     * based on the `userId` in the path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the currently authenticated user is the owner of an *existing* document.
     * CRITICAL: This must be used for all update and delete operations to prevent
     * acting on non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for the user's root document, typically storing profile information.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own user document: `create /users/user_abc`
     * @deny (list) Any user attempting to list all user documents: `list /users`
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if false; // Deleting user root documents is disallowed to prevent orphaning subcollections.
    }

    /**
     * @description Rules for a user's private journal entries.
     * @path /users/{userId}/journalEntries/{journalEntryId}
     * @allow (create) An authenticated user creating a journal entry in their own space: `create /users/user_abc/journalEntries/entry_123`
     * @deny (get) An authenticated user trying to read another user's entry: `get /users/user_xyz/journalEntries/entry_456`
     * @principle Enforces strict document ownership for all read and write operations.
     */
    match /users/{userId}/journalEntries/{journalEntryId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for a user's private tags for organizing journal entries.
     * @path /users/{userId}/tags/{tagId}
     * @allow (list) An authenticated user listing their own tags: `list /users/user_abc/tags`
     * @deny (update) An authenticated user trying to update another user's tag: `update /users/user_xyz/tags/tag_789`
     * @principle Enforces strict document ownership for all read and write operations.
     */
    match /users/{userId}/tags/{tagId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}